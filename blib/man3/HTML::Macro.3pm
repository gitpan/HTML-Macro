.\" Automatically generated by Pod::Man version 1.02
.\" Tue Dec 18 15:44:54 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Macro 3"
.TH Macro 3 "perl v5.6.0" "2001-12-18" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Macro \- generate dynamic \s-1HTML\s0 pages using templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use HTML::Macro;
\&  $ifp = HTML::Macro->new();
\&  $ifp->declare ('var', 'missing');
\&  $ifp->set ('var', 'value');
\&  $ifp->print ('test.html');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1HTML:\s0:Macro is a module to be used behind a web server (in \s-1CGI\s0 scripts). It
provides a convenient mechanism for generating \s-1HTML\s0 pages by combining
\&\*(L"dynamic\*(R" data derived from a database or other computation with \s-1HTML\s0
templates that represent fixed or \*(L"static\*(R" content of a page.
.PP
There are many different ways to accomplish what \s-1HTML:\s0:Macro does, including
\&\s-1ASP\s0, embedded perl, \s-1CFML\s0, etc, etc. The motivation behind \s-1HTML:\s0:Macro is to keep
everything that a graphic designer wants to play with *in a single \s-1HTML\s0
template*, and to keep as much as possible of what a perl programmer wants
to play with *in a perl file*.  Our thinking is that there are two
basically dissimilar tasks involved in producing a dynamic web page:
graphic design and programming. Even if one person is responsible for both
tasks, it is useful to separate them in order to aid clear thinking and
organized work.  I guess you could say the main motivation for this
separation is to make it easier for emacs (and other text processors,
including humans) to parse your files: it's yucky to have a lot of \s-1HTML\s0 in
a string in your perl file, and it's yucky to have perl embedded in a
special tag in an \s-1HTML\s0 file.
.PP
That said, \s-1HTML:\s0:Macro does provide for some simple programming constructs to
appear embedded in \s-1HTML\s0 code.  Think of it as a programming language on a
similar level as the C preprocessor.  \s-1HTML:\s0:Macro \*(L"code\*(R" is made to look like
\&\s-1HTML\s0 tags so it will be fairly innocuous for most HTML-oriented editors to
deal with.  At the moment \s-1HTML:\s0:Macro suports variables, conditionals, loops,
file interpolation and quoting (to inhibit all of the above).  \s-1HTML:\s0:Macro
variables are always surrounded with single or double hash marks: \*(L"#\*(R" or
\&\*(L"##\*(R".  Variables surrounded by double hash marks are subject to html entity
encoding; variables with single hash marks are substituted \*(L"as is\*(R" (like
single quotes in perl or \s-1UNIX\s0 shells).  Conditionals are denoted by the
<if> and <else> tags, and loops by the <loop> tag.
.PP
Usage:
.PP
Create a new \s-1HTML:\s0:Macro:
  \f(CW$ifp\fR = \s-1HTML:\s0:Macro->\fInew()\fR;
.PP
Optionally, declare the names of all the variables that will be substituted
on this page.  This has the effect of defining the value '' for all these
variables.
  \f(CW$ifp\fR->declare ('var', 'missing');
.PP
Set the values of one or more variables using \s-1HTML:\s0:Macro::set.
.PP
.Vb 1
\&  $ifp->set ('var', 'value');
.Ve
Or use \s-1IF\s0:Page::set_hash to set a whole bunch of values at once.  Typically
used with the value returned from a \s-1DBI:\s0:fetchrow_hashref.
.PP
.Vb 1
\&  $ifp->set_hash ( {'var' => 'value' } );
.Ve
Finally, process the template and print the result using \s-1HTML:\s0:Macro::print,
or save the value return by \s-1HTML:\s0:Macro::process.  
.PP
.Vb 3
\&    open CACHED_PAGE, '>page.html';
\&    print CACHED_PAGE, $ifp->process ('templates/page_template.html');
\&    close CACHED_PAGE;
.Ve
.Vb 1
\&    - or -
.Ve
.Vb 1
\&    $ifp->print ('test.html');
.Ve
As a convenience the \s-1IF\s0:Page::print function prints the processed template
that would be returned by \s-1HTML:\s0:Macro::process, preceded by appropriate \s-1HTTP\s0
headers (Content-Type and no-cache directives).
.PP
\&\s-1HTML:\s0:Macro::process attempts to perform a substitution on any word beginning
and ending with single or double hashmarks (#) , such as ##NAME##.
A word is any sequence of alphanumerics and underscores.  If the
\&\s-1HTML:\s0:Macro has a matching variable, its value is substituted for the word in
the template everywhere it appears.  A matching variable may match the
template word literally, or it may match one of the following:
.PP
the word with the delimiting hash marks stripped off ('\s-1NAME\s0' in the example)
the word without delimiters lowercased ('name')
the word without delimiters uppercased ('\s-1NAME\s0')
.PP
A typical usage is to stuff all the values returned from
\&\s-1DBI:\s0:fetchrow_hashref into an \s-1HTML:\s0:Macro.  Then \s-1SQL\s0 column names are to be
mapped to template variables.  Databases have different case conventions
for column names; providing the case insensitivity and stripping the
underscores allows templates to be written in a portable fashion while
preserving an upper-case convention for template variables.
.PP
\&\s-1HTML\s0 entity quoting
.PP
Variables surrounded by double delimiters are subject to \s-1HTML\s0 entity encoding.
That is, >, < and "\*(L"  occuring in the variables value are replaced by their
corresponding \s-1HTML\s0 entities.  Variables surrounded by single delimiters are not
quoted; they are substituted \*(R"as is"
.PP
Conditionals
.PP
Conditional tags take one of the following forms:
.PP
<if expr=\*(L"perl expression\*(R"> 
 \s-1HTML\s0 block 1
<else/>
 \s-1HTML\s0 block 2
</if>
.PP
or
.PP
<if expr=\*(L"perl expression\*(R"> 
 \s-1HTML\s0 block 1
<else>
 \s-1HTML\s0 block 2
</else>
</if>
.PP
or simply
.PP
<if expr=\*(L"perl expression\*(R"> 
 \s-1HTML\s0 block 1
</if>
.PP
Conditional tags are processed by evaluating the value of the \*(L"expr\*(R"
attribute as a perl expression.  The entire conditional tag structure is
replaced by the \s-1HTML\s0 in the first block if the expression is true, or the
second block (or nothing if there is no else clause) if the expressin is
false.
.PP
Conditional expressions are subject to variable substitution, allowing for
constructs such as:
.PP
You have #NUM_ITEMS# item<if \*(L"#NUM_THINGS# > 1\*(R">s</if> in your basket.
.PP
File Interpolation
.PP
It is often helpful to structure \s-1HTML\s0 by separating commonly-used chunks
(headers, footers, etc) into separate files.  \s-1HTML:\s0:Macro provides the
<include/> tag for this purpose.  Markup such as <include/
file=\*(L"file.html\*(R"> gets replaced by the contents of file.html, which is
itself subject to evaluation by \s-1HTML:\s0:Macro.  If the \*(L"asis\*(R" attribute is
present: <include/ file=\*(L"quoteme.html\*(R" asis>, the file is included \*(L"as is\*(R";
without any further evaluation.
.PP
Also, \s-1HTML:\s0:Macro provides support for an include path.  This allows common
\&\*(L"part\*(R" files to be placed in a common place.  \s-1HTML:\s0:Macro::push_incpath adds
to the path, as in \f(CW$ifp\fR->push_incpath (\*(L"/path/to/include/files\*(R").  The
current directory (of the file being processed) is always checked first,
followed by each directory on the incpath.  When paths are added to the
incpath they are always converted to absolute paths, relative to the
working directory of the invoking script.  Thus, if your script is running
in \*(L"/cgi-bin\*(R" and calls push_incpath(\*(L"include\*(R"), this adds
\&\*(L"/cgi-bin/include\*(R" to the incpath.
.PP
Quoting
.PP
The preceding transformations can be inhibited by the use of the \*(L"<quote>\*(R"
tag.  Any markup enclosed by <quote> ... </quote> is passed on as-is.
quote tags may be nested to provide for multiple passes of macro
substitution.
.PP
.Vb 5
\&    This could be useful if you need to include markup like <if> in your
\&    output, although that could be more easily accomplished by the usual
\&    HTML entity encodings: escaping < with &lt; and so on.  The real reason
\&    this is here is to enable multiple passes of HTML::Macro to run on "proto"
\&    templates that just generate other templates.
.Ve
Quote tags have an optional \*(L"preserve\*(R" attribute.  If \*(L"preserve\*(R" is
present, its value is evaluated (as with if above), and if the result is
true, the quote tag is preserved in the output.  Otherwise, the tag is
swallowed and the quoting behavior is inhibited.  So:
.PP
<quote preserve=\*(L"1\*(R">xyzzy<include/ file=\*(L"foo\*(R"></quote>  
.PP
would be passed over unchanged,
.PP
and
.PP
<quote preserve=\*(L"0\*(R"><include/ file=\*(L"foo\*(R"></quote>
.PP
would be replaced by the contents of the file named \*(L"foo\*(R".
.PP
Loops
.PP
Finally, the <loop> tag provides for repeated blocks of \s-1HTML\s0, with
subsequent iterations evaluated in different contexts.  For more about
loops, see the \s-1IF\s0:Page::Loop documentation.
.PP
\&\s-1HTML:\s0:Macro is copyright (c) 2000 by Michael Sokolov and Interactive Factory
(sm).  All rights are reserved.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Sokolov, sokolov@ifactory.com
.SH "SEE ALSO HTML::Macro::Loop"
.IX Header "SEE ALSO HTML::Macro::Loop"
\&\fIperl\fR\|(1).
